import{_ as s,c as a,o as e,a3 as i}from"./chunks/framework.BhrxS_qF.js";const k=JSON.parse('{"title":"CPU性能","description":"","frontmatter":{},"headers":[],"relativePath":"Linux/性能优化实战/CPU性能.md","filePath":"Linux/性能优化实战/CPU性能.md","lastUpdated":1732241785000}'),t={name:"Linux/性能优化实战/CPU性能.md"},n=i('<h1 id="cpu性能" tabindex="-1">CPU性能 <a class="header-anchor" href="#cpu性能" aria-label="Permalink to &quot;CPU性能&quot;">​</a></h1><h2 id="平均负载" tabindex="-1">平均负载 <a class="header-anchor" href="#平均负载" aria-label="Permalink to &quot;平均负载&quot;">​</a></h2><p>通过执行 <code>man uptime</code> 命令，来了解平均负载的详细解释。</p><p>简单来说，平均负载是指单位时间内，系统处于<strong>可运行状态</strong>和<strong>不可中断状态</strong>的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。</p><p><strong>可运行状态</strong>和<strong>不可中断状态</strong> 所谓可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。<br> 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。</p><p>比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。</p><p>所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。</p><p>举例说明<strong>平均活跃进程数</strong>，那么最理想的，就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。比如当平均负载为 2 时，意味着什么呢？</p><ul><li>在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。</li><li>在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。</li><li>而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。</li></ul><p>CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：</p><ul><li>CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；</li><li>I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；</li><li>大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</li></ul><h2 id="平均负载受影响因素" tabindex="-1">平均负载受影响因素 <a class="header-anchor" href="#平均负载受影响因素" aria-label="Permalink to &quot;平均负载受影响因素&quot;">​</a></h2><h3 id="cpu密集型进程" tabindex="-1">CPU密集型进程 <a class="header-anchor" href="#cpu密集型进程" aria-label="Permalink to &quot;CPU密集型进程&quot;">​</a></h3><p>使用stress命令，模拟CPU使用率100%的场景</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stress</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --cpu</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --timeout</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 600</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>使用uptime命令查看平均负载情况</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> uptime</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>',17),l=[n];function p(r,h,o,d,c,u){return e(),a("div",null,l)}const P=s(t,[["render",p]]);export{k as __pageData,P as default};
